<pre><code>Document number: Dxxxx=14-xxxx
Date:            2014-10-24
Project:         Programming Language C++, Library Evolution Working Group
Reply-to:        Rein Halbersma &lt;rhalbersma@gmail.com&gt;
</code></pre>

<h1>User-Defined Literals for <code>size_t</code> (and <code>ptrdiff_t</code>)</h1>

<h2>Introduction</h2>

<p>Following earlier <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/tGoPjUeHlKo">discussion</a> on <code>std-proposals</code>, we propose the user-defined suffix <code>z</code> for <code>size_t</code> literals. This allows writing code in <a href="http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">Almost Always Auto style</a></p>

<pre><code>for (auto i = 0z; i &lt; a.size(); ++i) { /* use i and a[i] */ }
</code></pre>

<p>that will let the loop variable <code>i</code> be of type <code>size_t</code>. Similarly, we propose the suffix <code>t</code> for <code>ptrdiff_t</code> literals. </p>

<h2>Motivation and Scope</h2>

<p>The main motivations for this proposal are:</p>

<ul>
<li><code>int</code> is the default type deduced from integer literals;</li>
<li><code>size_t</code> is almost unavoidable when using the Standard Library;</li>
<li><code>ptrdiff_t</code> is significantly less ubiquitous, but still hard to avoid when doing iterator related manipulations;</li>
<li>comparisons and arithmetic with integer types of mixed signs or different conversion ranks can lead to surprises;</li>
<li>surprises range from (pedantic) compiler warnings, value conversions, or even undefined behavior;</li>
<li>eliminating these surprises by explicitly typing <code>size_t</code> and <code>ptrdiff_t</code> literals is rather verbose;</li>
<li>user-defined literals are a type-safe and succinct way to express coding intent;</li>
<li>the suffixes <code>z</code> and <code>t</code> are consisent with the length modifiers for formatted I/O in the C standard library.  </li>
</ul>

<h2>Impact On the Standard</h2>

<p>This proposal does not depend on other library components, and nothing depends on it. It is a pure extension, but does require additions (though no modifications) to the standard header <code>&lt;cstddef&gt;</code>, as outlined in the section <strong>Proposed Wording</strong> below. It can be implemented using C++11 compilers and libraries, and it does not require language or library features that are not part of C++11.</p>

<p>There are, however, three active CWG issues (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1266">cwg#1266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1620">cwg#1620</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1735">cwg#1735</a>) that could impact this proposal. All three issues note that in implementations with extended integer types, the decimal-literal in a user-defined-integer-literal might be too large for an <code>unsigned long long</code> to represent. Suggestions (but no formal proposals) were made to either fall back to a raw literal operator or a literal operator template, or to allow a parameter of an extended integer type. The latter suggestion would be easiest to incorporate into this proposal.</p>

<h2>Design Decisions</h2>

<p>The chosen naming of the literal suffixes <code>z</code> and <code>t</code> was motivated by the corresponding length modifiers for formatted I/O in the C standard library header <code>&lt;stdio.h&gt;</code>. See 7.21.6.1/7 for <code>fprintf</code> and 7.21.6.2/11 <code>fscanf</code>, numbered relative to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1539.pdf">WG14/N1539</a>.</p>

<p>The consequences of adopting the proposed literal suffixes into the Standard are:</p>

<ul>
<li>both novices and occasional programmers, as well as experienced library implementors, can use left-to-right <code>auto</code> variable initializations with <code>size_t</code> and <code>ptrdiff_t</code> literals, without having to define their own literal suffixes with leading underscores <code>_z</code> and <code>_t</code> in order to do so;</li>
<li>other existing or future Standard Library types are prevented from adopting the same literal suffixes, unless they use overloads of the corresponding <code>operator""</code> that take arguments other than <code>unsigned long long</code>. </li>
</ul>

<p>This proposal follows the existing practice established in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">WG21/N3642</a> with respect to the <code>constexpr</code> (present) and <code>noexcept</code> (absent) specifiers, as well as the usage of an appropriately named <code>inline namespace std::literals::support_literals</code>.</p>

<p>There are no decisions left up to implementers, because the suggested wording below fully specifies the proposed functionality. We are not aware of similar libraries in use. There is a <a href="https://bitbucket.org/rhalbersma/xstd/src/bd4212118116a8b28d97b69d30472e2f1e80f322/include/xstd/cstddef.hpp?at=default">reference implementation</a> and small <a href="https://bitbucket.org/rhalbersma/xstd/src/608b4257b4ec980272edd0876be45a9391d83274/test/src/cstddef.cpp?at=default">test suite</a> available for inspection. Note that the reference implementation uses <code>namespace xstd</code> and underscored suffixes <code>_t</code> and <code>_z</code> because the tested compiler <code>clang</code> will enforce the restriction from <code>[lex.ext]/10</code> that a program containing a user-defined suffix without an underscore is ill-formed, no diagnostic required.   </p>

<h2>Proposed Wording</h2>

<p>Insert in subclause <code>[support.types]/1</code> in the synopsis of header <code>&lt;cstddef&gt;</code> at the appropriate place the namespace <code>std::literals::support_literals</code>: </p>

<pre><code>        namespace std {
          inline namespace literals {
            inline namespace support_literals {
              constexpr size_t operator "" z(unsigned long long);       
              constexpr ptrdiff_t operator "" t(unsigned long long);        
            }
          }
        }
</code></pre>

<p>Insert a new subclause <code>[support.literals]</code> between <code>[support.types]</code> and <code>[support.limits]</code> as follows (numered relative to <a href="https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf">WG21/N4140</a>):</p>

<blockquote>
  <p><strong>18.3 Suffixes for support types [support.literals]</strong></p>

<p>1 This section describes literal suffixes for constructing <code>size_t</code> and <code>ptrdiff_t</code> literals. The suffixes <code>z</code> and <code>t</code> create numbers of the types <code>size_t</code> and <code>ptrdiff_t</code>, respectively. </p>

<pre><code>constexpr size_t operator "" z(unsigned long long u);
</code></pre>

<p>2 Returns: <code>static_cast&lt;size_t&gt;(u)</code>.</p>

<pre><code>constexpr ptrdiff_t operator "" t(unsigned long long u);
</code></pre>

<p>3 Returns: <code>static_cast&lt;ptrdiff_t&gt;(u)</code>.</p>
</blockquote>

<h2>Acknowledgments</h2>

<p>We gratefully acknowledge feedback from Jerry Coffin and Andy Prowl on <code>&lt;Lounge C++&gt;</code> and from Daniel Kr√ºgler and Melissa Mears on <code>std-proposals</code>.</p>

<h2>References</h2>

<p><code>[std-proposals]</code>: Morwenn Edrahir, <em>User defined literal for size_t</em> <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/tGoPjUeHlKo">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/tGoPjUeHlKo</a> </p>

<p><code>[N3642]</code>: Peter Sommerlad, <em>User-defined Literals for Standard Library Types (part 1 - version 4)</em> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf</a></p>

<p><code>[GotW #94]</code>: Herb Sutter, <em>AAA Style (Almost Always Auto)</em> <a href="http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</a></p>
